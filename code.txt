.text
.globl main
#-------------------------------------------- Compiler Functions --------------------------------------------#
ReadLine:
        li $t0 , 0
        li $t1 , '\n'
        loopReadLine:
            li $v0 , 12
            syscall
            addi $t0 , $t0 , 1
            addi $sp , $sp , -1
            beq $v0 , $t1 , endLoopReadLine
            sb $v0 , 1($sp)
            j loopReadLine
            endLoopReadLine:
            sb $zero , 1($sp)
        # Allocating Space in Heap
        li $v0 , 9
        addi $a0 , $t0 , 0
        syscall
        move $t1 , $v0 # $t1 Holds the address of String in Heap
        # Moving String from stack to Heap
        addi $t0 , $t0 , -1 # $t0 is the offset of char in Heap ( from the end of allocated area )
        loopMoveString:
            add $t2 , $t1 , $t0 # $t2 is Char address in Heap
            lb $t3 , 1($sp)
            sb $t3 , 0($t2)
            beq $t0 , $zero , endLoopMoveString
            addi $sp , $sp , 1
            addi $t0 , $t0 , -1
            j loopMoveString
        endLoopMoveString:
        addi $sp , $sp , 1
        # Here $v0 Contains the string address allocated in Heap
        jr $ra

StringsEquality:
	move $t1 , $a0 # String 1
	move $t2 , $a1 # String 2
	li $t5 , 1
	loopCheckEquality:
		lb $t3 , 0($t1)
		lb $t4 , 0($t2)
		bne $t3 , $t4 , StringsNotEqualLabel
		beq $t3 , $zero , endLoopCheckEquality
		addi $t1 , $t1 , 1
		addi $t2 , $t2 , 1
		j loopCheckEquality
		StringsNotEqualLabel:
		li $t5 , 0
	endLoopCheckEquality:
	move $v0 , $t5
	jr $ra

StringsInequality:
	addi $sp , $sp , -4
	sw $ra , 4($sp)
	jal StringsEquality
	addi $sp , $sp , 4
	lw $ra , 0($sp)
	nor $v0 , $v0 , $v0
	addi $v0 , $v0 , 2 # All 1's from bit[1] to left becomes Zero
	jr $ra
#-------------------------------------------- Program --------------------------------------------#
fact: # Start function
addi $s5 , $sp , 0 # Storing $sp of function at beginning in $s5
# Function Body :
# Begin of Statement Block
addi $sp , $sp , -0 # Allocate From Stack For Block Statement Variables
addi $fp , $sp , 4
# Calculating IF Condition
# Loading Address of ID : a
addi $s7, $fp, 0
sw $s7, 0($sp) # Push Address of a to Stack
addi $sp, $sp, -4
# Load Value from Address of ID : a
lw $t0, 4($sp)
lw $t0 , 0($t0)
sw $t0 , 4($sp) # Value of a Pushed to Stack
# Int Constant : 1
li $t0 , 1
sw $t0 , 0($sp)
addi $sp, $sp, -4
# Equal Expression
lw $t0 , 8($sp)
lw $t1 , 4($sp)
seq $t0 , $t0 , $t1
sw $t0 , 8($sp)
addi $sp , $sp , 4
# Loading IF Condition
addi $sp , $sp , 4
lw $t0 , 0($sp)
beqz $t0 , L0 # Jumping to end label if expression is false
# IF Statement Body
# Begin of Statement Block
addi $sp , $sp , -0 # Allocate From Stack For Block Statement Variables
addi $fp , $sp , 4
# Int Constant : 1
li $t0 , 1
sw $t0 , 0($sp)
addi $sp, $sp, -4
lw $v0 , 4($sp) # Loading Return Value of function
addi $sp , $sp , 4
move $sp , $s5
jr $ra # Return Function
addi $sp , $sp , 0 # UnAllocate Stack Area (Removing Block Statement Variables)
addi $fp ,$sp , 4
# End of Statement Block
L0:
# Loading Address of ID : a
addi $s7, $fp, 0
sw $s7, 0($sp) # Push Address of a to Stack
addi $sp, $sp, -4
# Load Value from Address of ID : a
lw $t0, 4($sp)
lw $t0 , 0($t0)
sw $t0 , 4($sp) # Value of a Pushed to Stack
# Storing Frame Pointer and Return Address Before Calling the function : fact
addi $sp , $sp , -12
sw $fp , 4($sp)
sw $ra , 8($sp)
sw $s5 , 12($sp)
# Function Arguments
# Loading Address of ID : a
addi $s7, $fp, 0
sw $s7, 0($sp) # Push Address of a to Stack
addi $sp, $sp, -4
# Load Value from Address of ID : a
lw $t0, 4($sp)
lw $t0 , 0($t0)
sw $t0 , 4($sp) # Value of a Pushed to Stack
# Int Constant : 1
li $t0 , 1
sw $t0 , 0($sp)
addi $sp, $sp, -4
# Sub Expression
lw $t0 , 8($sp)
lw $t1 , 4($sp)
sub $t0 , $t0 , $t1
sw $t0 , 8($sp)
addi $sp , $sp , 4
jal fact # Calling Function
# Pop Arguments of function
addi $sp , $sp , 4
# Load Back Frame Pointer and Return Address After Function call
lw $fp , 4($sp)
lw $ra , 8($sp)
lw $s5 , 12($sp)
addi $sp , $sp , 8
sw $v0 , 4($sp) # Push Return Value from function to Stack
# Mul Expression
lw $t0 , 8($sp)
lw $t1 , 4($sp)
mul $t0 , $t0 , $t1
sw $t0 , 8($sp)
addi $sp , $sp , 4
lw $v0 , 4($sp) # Loading Return Value of function
addi $sp , $sp , 4
move $sp , $s5
jr $ra # Return Function
addi $sp , $sp , 0 # UnAllocate Stack Area (Removing Block Statement Variables)
addi $fp ,$sp , 4
# End of Statement Block
fact_end :
jr $ra
fib: # Start function
addi $s5 , $sp , 0 # Storing $sp of function at beginning in $s5
# Function Body :
# Begin of Statement Block
addi $sp , $sp , -0 # Allocate From Stack For Block Statement Variables
addi $fp , $sp , 4
# Calculating IF Condition
# Loading Address of ID : n
addi $s7, $fp, 0
sw $s7, 0($sp) # Push Address of n to Stack
addi $sp, $sp, -4
# Load Value from Address of ID : n
lw $t0, 4($sp)
lw $t0 , 0($t0)
sw $t0 , 4($sp) # Value of n Pushed to Stack
# Int Constant : 1
li $t0 , 1
sw $t0 , 0($sp)
addi $sp, $sp, -4
# Equal Expression
lw $t0 , 8($sp)
lw $t1 , 4($sp)
seq $t0 , $t0 , $t1
sw $t0 , 8($sp)
addi $sp , $sp , 4
# Loading Address of ID : n
addi $s7, $fp, 0
sw $s7, 0($sp) # Push Address of n to Stack
addi $sp, $sp, -4
# Load Value from Address of ID : n
lw $t0, 4($sp)
lw $t0 , 0($t0)
sw $t0 , 4($sp) # Value of n Pushed to Stack
# Int Constant : 2
li $t0 , 2
sw $t0 , 0($sp)
addi $sp, $sp, -4
# Equal Expression
lw $t0 , 8($sp)
lw $t1 , 4($sp)
seq $t0 , $t0 , $t1
sw $t0 , 8($sp)
addi $sp , $sp , 4
# Or Expression
lw $t0 , 8($sp)
lw $t1 , 4($sp)
or $t0 , $t0 , $t1
sw $t0 , 8($sp)
addi $sp , $sp , 4
# Loading IF Condition
addi $sp , $sp , 4
lw $t0 , 0($sp)
beqz $t0 , L1 # Jumping to end label if expression is false
# IF Statement Body
# Begin of Statement Block
addi $sp , $sp , -0 # Allocate From Stack For Block Statement Variables
addi $fp , $sp , 4
# Int Constant : 1
li $t0 , 1
sw $t0 , 0($sp)
addi $sp, $sp, -4
lw $v0 , 4($sp) # Loading Return Value of function
addi $sp , $sp , 4
move $sp , $s5
jr $ra # Return Function
addi $sp , $sp , 0 # UnAllocate Stack Area (Removing Block Statement Variables)
addi $fp ,$sp , 4
# End of Statement Block
L1:
# Storing Frame Pointer and Return Address Before Calling the function : fib
addi $sp , $sp , -12
sw $fp , 4($sp)
sw $ra , 8($sp)
sw $s5 , 12($sp)
# Function Arguments
# Loading Address of ID : n
addi $s7, $fp, 0
sw $s7, 0($sp) # Push Address of n to Stack
addi $sp, $sp, -4
# Load Value from Address of ID : n
lw $t0, 4($sp)
lw $t0 , 0($t0)
sw $t0 , 4($sp) # Value of n Pushed to Stack
# Int Constant : 1
li $t0 , 1
sw $t0 , 0($sp)
addi $sp, $sp, -4
# Sub Expression
lw $t0 , 8($sp)
lw $t1 , 4($sp)
sub $t0 , $t0 , $t1
sw $t0 , 8($sp)
addi $sp , $sp , 4
jal fib # Calling Function
# Pop Arguments of function
addi $sp , $sp , 4
# Load Back Frame Pointer and Return Address After Function call
lw $fp , 4($sp)
lw $ra , 8($sp)
lw $s5 , 12($sp)
addi $sp , $sp , 8
sw $v0 , 4($sp) # Push Return Value from function to Stack
# Storing Frame Pointer and Return Address Before Calling the function : fib
addi $sp , $sp , -12
sw $fp , 4($sp)
sw $ra , 8($sp)
sw $s5 , 12($sp)
# Function Arguments
# Loading Address of ID : n
addi $s7, $fp, 0
sw $s7, 0($sp) # Push Address of n to Stack
addi $sp, $sp, -4
# Load Value from Address of ID : n
lw $t0, 4($sp)
lw $t0 , 0($t0)
sw $t0 , 4($sp) # Value of n Pushed to Stack
# Int Constant : 2
li $t0 , 2
sw $t0 , 0($sp)
addi $sp, $sp, -4
# Sub Expression
lw $t0 , 8($sp)
lw $t1 , 4($sp)
sub $t0 , $t0 , $t1
sw $t0 , 8($sp)
addi $sp , $sp , 4
jal fib # Calling Function
# Pop Arguments of function
addi $sp , $sp , 4
# Load Back Frame Pointer and Return Address After Function call
lw $fp , 4($sp)
lw $ra , 8($sp)
lw $s5 , 12($sp)
addi $sp , $sp , 8
sw $v0 , 4($sp) # Push Return Value from function to Stack
# Add Expression
lw $t0 , 8($sp)
lw $t1 , 4($sp)
add $t0 , $t0 , $t1
sw $t0 , 8($sp)
addi $sp , $sp , 4
lw $v0 , 4($sp) # Loading Return Value of function
addi $sp , $sp , 4
move $sp , $s5
jr $ra # Return Function
addi $sp , $sp , 0 # UnAllocate Stack Area (Removing Block Statement Variables)
addi $fp ,$sp , 4
# End of Statement Block
fib_end :
jr $ra
main: # Start function
addi $s5 , $sp , 0 # Storing $sp of function at beginning in $s5
# Function Body :
# Begin of Statement Block
addi $sp , $sp , -0 # Allocate From Stack For Block Statement Variables
addi $fp , $sp , 4
# Storing Frame Pointer and Return Address Before Calling the function : fact
addi $sp , $sp , -12
sw $fp , 4($sp)
sw $ra , 8($sp)
sw $s5 , 12($sp)
# Function Arguments
# Int Constant : 4
li $t0 , 4
sw $t0 , 0($sp)
addi $sp, $sp, -4
jal fact # Calling Function
# Pop Arguments of function
addi $sp , $sp , 4
# Load Back Frame Pointer and Return Address After Function call
lw $fp , 4($sp)
lw $ra , 8($sp)
lw $s5 , 12($sp)
addi $sp , $sp , 8
sw $v0 , 4($sp) # Push Return Value from function to Stack
# Print : 
addi $sp , $sp , 4 # Pop Expression of Print
lw $a0 , 0($sp)
li $v0 , 1
syscall
li $a0 , '\n'
li $v0 , 11
syscall
# Storing Frame Pointer and Return Address Before Calling the function : fib
addi $sp , $sp , -12
sw $fp , 4($sp)
sw $ra , 8($sp)
sw $s5 , 12($sp)
# Function Arguments
# Int Constant : 8
li $t0 , 8
sw $t0 , 0($sp)
addi $sp, $sp, -4
jal fib # Calling Function
# Pop Arguments of function
addi $sp , $sp , 4
# Load Back Frame Pointer and Return Address After Function call
lw $fp , 4($sp)
lw $ra , 8($sp)
lw $s5 , 12($sp)
addi $sp , $sp , 8
sw $v0 , 4($sp) # Push Return Value from function to Stack
# Print : 
addi $sp , $sp , 4 # Pop Expression of Print
lw $a0 , 0($sp)
li $v0 , 1
syscall
li $a0 , '\n'
li $v0 , 11
syscall
addi $sp , $sp , 0 # UnAllocate Stack Area (Removing Block Statement Variables)
addi $fp ,$sp , 4
# End of Statement Block
main_end :
jr $ra


.data
str_false : .asciiz "false" 
str_true : .asciiz "true" 
str_bool : .word str_false , str_true
