#-------------------------------------------- Compiler Functions --------------------------------------------#
ReadLine:
        li $t0 , 0
        li $t1 , '\n'
        loopReadLine:
            li $v0 , 12
            syscall
            addi $t0 , $t0 , 1
            addi $sp , $sp , -1
            beq $v0 , $t1 , endLoopReadLine
            sb $v0 , 1($sp)
            j loopReadLine
            endLoopReadLine:
            sb $zero , 1($sp)
        # Allocating Space in Heap
        li $v0 , 9
        addi $a0 , $t0 , 0
        syscall
        move $t1 , $v0 # $t1 Holds the address of String in Heap
        # Moving String from stack to Heap
        addi $t0 , $t0 , -1 # $t0 is the offset of char in Heap ( from the end of allocated area )
        loopMoveString:
            add $t2 , $t1 , $t0 # $t2 is Char address in Heap
            lb $t3 , 1($sp)
            sb $t3 , 0($t2)
            beq $t0 , $zero , endLoopMoveString
            addi $sp , $sp , 1
            addi $t0 , $t0 , -1
            j loopMoveString
        endLoopMoveString:
        addi $sp , $sp , 1
        # Here $v0 Contains the string address allocated in Heap
        jr $ra

StringsEquality:
	move $t1 , $a0 # String 1
	move $t2 , $a1 # String 2
	li $t5 , 1
	loopCheckEquality:
		lb $t3 , 0($t1)
		lb $t4 , 0($t2)
		bne $t3 , $t4 , StringsNotEqualLabel
		beq $t3 , $zero , endLoopCheckEquality
		addi $t1 , $t1 , 1
		addi $t2 , $t2 , 1
		j loopCheckEquality
		StringsNotEqualLabel:
		li $t5 , 0
	endLoopCheckEquality:
	move $v0 , $t5
	jr $ra

StringsInequality:
	addi $sp , $sp , -4
	sw $ra , 4($sp)
	jal StringsEquality
	addi $sp , $sp , 4
	lw $ra , 0($sp)
	nor $v0 , $v0 , $v0
	addi $v0 , $v0 , 2 # All 1's from bit[1] to left becomes Zero
	jr $ra

PrintDouble:
    # Assume $f4 is A*.BCDEFG*
    mov.s $f12 , $f4
    li.s $f10 , 10000.0
    cvt.w.s $f11,$f12
    mfc1 $t0,$f11 # $t0 is A*
    move $a0 , $t0
    li $v0 , 1
    syscall # Printing A*
	li $a0 , '.'
    li $v0 , 11
    syscall # Printing dot
	li.s $f10 , 10.0
    mtc1 $t0 , $f11
    cvt.s.w $f11 , $f11 # $f11 has A*.0
    sub.s $f11 , $f12 , $f11 # $f11 is 0.BCDEFG*
    abs.s $f11 , $f11
	# Loop digits decimal
	li $t2 , 3
	print_double_loop_decimal:
	mul.s $f11 , $f11 , $f10 # $f11 is { B.CDEFG* or C.DEFG* or D.EFG* or E.FG* }
    cvt.w.s $f12,$f11
    mfc1 $t0,$f12 # $t0 is { B or C or D or E }
    cvt.s.w $f12 , $f12 # $f12 is { B.0 or C.0 or D.0 , E.0 }
    sub.s $f11 , $f11 , $f12 # $f11 is { 0.CDEFG* or 0.DEFG* or 0.EFG* or 0.FG* }
	bne $t2 , $zero , not_the_fourth_digit
    li.s $f0 , 0.5
    c.le.s $f11 , $f0
    bc1t not_the_fourth_digit
    addi $t0 , $t0 , 1
    not_the_fourth_digit:
	move $a0 , $t0
	li $v0 , 1
	syscall
	addi $t2 , $t2 , -1
	bne $t2 , -1 , print_double_loop_decimal
    jr $ra

itod:
	lw $t0 , 4($sp)
    mtc1 $t0, $f12
    cvt.s.w $f12, $f12
    mov.s $f0 , $f12
	jr $ra

dtoi:
	l.s $f0 , 4($sp)
	cvt.w.s $f1,$f0
    mfc1 $v0,$f1 # $v0 is floor of double
    # Convert $v0 to double
    mtc1 $v0 , $f1
    cvt.s.w $f1 , $f1
    # get decimal
    sub.s $f0 , $f0 , $f1
    li.s $f1 , 0.5
    c.le.s $f0 , $f1
    bc1t end_conversion_dtoi
    addi $v0 , $v0 , 1
    end_conversion_dtoi:
	jr $ra

itob:
	lw $v0 , 4($sp)
	beqz $v0 , end_conversion_itob
	li $v0 , 1
	end_conversion_itob:
	jr $ra

btoi:
    lw $v0 , 4($sp)
	jr $ra
#-------------------------------------------- Program --------------------------------------------#
